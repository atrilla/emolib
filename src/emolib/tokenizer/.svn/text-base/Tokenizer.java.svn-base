/*
 * File    : Tokenizer.java
 * Created : 5-Nov-2008
 * By      : atrilla
 *
 * Emolib - Emotional Library
 *
 * Copyright (c) 2008 Alexandre Trilla &
 * 2007-2012 Enginyeria i Arquitectura La Salle (Universitat Ramon Llull)
 *
 * This file is part of Emolib.
 *
 * You should have received a copy of the rights granted with this
 * distribution of EmoLib. See COPYING.
 */

package emolib.tokenizer;

import emolib.util.conf.*;
import emolib.util.proc.*;

import java.util.ArrayList;

/**
 * The <i>Tokenizer</i> abstract class defines the general structure to perform the
 * tokenisation process, which splits a text string into individual units, called tokens.
 * <p>
 * The Tokenizer provides a means of structured data retrieval from the incoming 
 * text, which is basically the
 * words in question being analysed (lexicon units) and their correspondent word-classes (lexical
 * categories). So, the Tokenizer constitutes the Text Data feeder to the 
 * processing pipeline, aka the INPUTTER, therefore it implements the
 * "inputData" method.
 * </p>
 * <p>
 * These tokens are expressed in regular patterns as established by the grammar of the
 * language.
 * </p>
 * <p>
 * The child classes that will inherit the methods from this parent (abstract) class will be
 * generated by the <a href="https://javacc.dev.java.net/">JavaCC</a> parser/scanner generator
 * for Java. This tool eases the production of a grammar through the specification of its
 * lexicon (words/tokens) and its syntax to then create the correspondent Java class,
 * i.e., the lexical analyser, to detect matches to this grammar.
 * </p>
 * <p>
 * By following this implementation, two important goals are brought to success:
 * <ul>
 *     <li>
 *     The determination of the admissible words of a language, achieved by
 *     matching the incoming text units to the tokens described in the grammar.
 *     </li>
 *     <li>
 *     The verification that the order of the tokens matches the rules
 *     described by the syntax of the grammar.
 *     </li>
 * </ul>
 * </p>
 * <p>
 * This open definition of the tokenisation process (through parsing the
 * incoming text with a well defined grammar) enables a wide range of applications such as
 * Named Entity Tagging, Part-Of-Speech Tagging, morphological analysis, etc.
 * The definition of the grammar (lexicon + syntax) must be suited to the task.
 * </p>
 * <p>
 * Once the text is tokenised (and thus categorised) it becomes more manageable.
 * In the case that concerns EmoLib, for example,
 * the words that are of no interest are the words that don't convey or modify affect,
 * i.e., "stop words" such as function words, 
 * and they can hence be more easily filtered out if the input text is tokenised.
 * </p>
 * <p>
 * The words that actually have an affective content, namely nouns, verbs and adjectives,
 * are marked as affective containers. Other words that don't contain any affect by
 * themselves but have an influence on the nearby affective words are marked as modifiers.
 * These are basically quantitative adverbs. EmoLib defines 3 levels of modification,
 * defined through the external configuration file. Whether their value is positive or
 * negative, the adverb denotes positive or negative intention.
 * </p>
 *
 * @author Alexandre Trilla (atrilla@salle.url.edu)
 */
public abstract class Tokenizer extends TextDataProcessor {

    public final static String PROP_POSITIVE_MODIFIER_1 = "positive_modifier_1";
    public final static String PROP_POSITIVE_MODIFIER_2 = "positive_modifier_2";
    public final static String PROP_POSITIVE_MODIFIER_3 = "positive_modifier_3";

    public final static String PROP_NEGATIVE_MODIFIER_1 = "negative_modifier_1";
    public final static String PROP_NEGATIVE_MODIFIER_2 = "negative_modifier_2";
    public final static String PROP_NEGATIVE_MODIFIER_3 = "negative_modifier_3";

    public final static String PROP_NEGATION = "negation";


    public float positiveModifier1;
    public float positiveModifier2;
    public float positiveModifier3;

    public float negativeModifier1;
    public float negativeModifier2;
    public float negativeModifier3;

    public float negation;


    private String word;
    private String wordClass;
    private String wordEmotionalContent;
    private ArrayList wordModifierValue;


    /* (non-Javadoc)
     * @see emolib.util.conf.Configurable#register(java.lang.String, emolib.util.conf.Registry)
     */
    public void register(String name, Registry registry) throws PropertyException {
        super.register(name, registry);
        registry.register(PROP_POSITIVE_MODIFIER_1, PropertyType.FLOAT);
        registry.register(PROP_POSITIVE_MODIFIER_2, PropertyType.FLOAT);
        registry.register(PROP_POSITIVE_MODIFIER_3, PropertyType.FLOAT);
        registry.register(PROP_NEGATIVE_MODIFIER_1, PropertyType.FLOAT);
        registry.register(PROP_NEGATIVE_MODIFIER_2, PropertyType.FLOAT);
        registry.register(PROP_NEGATIVE_MODIFIER_3, PropertyType.FLOAT);
        registry.register(PROP_NEGATION, PropertyType.FLOAT);
    }


    /* (non-Javadoc)
     * @see emolib.util.conf.Configurable#newProperties(emolib.util.conf.PropertySheet)
     */
    public void newProperties(PropertySheet ps) throws PropertyException {
        super.newProperties(ps);
        positiveModifier1 = ps.getFloat(PROP_POSITIVE_MODIFIER_1, Float.parseFloat("0.25"));
        positiveModifier2 = ps.getFloat(PROP_POSITIVE_MODIFIER_2, Float.parseFloat("0.40"));
        positiveModifier3 = ps.getFloat(PROP_POSITIVE_MODIFIER_3, Float.parseFloat("0.66"));
        negativeModifier1 = ps.getFloat(PROP_NEGATIVE_MODIFIER_1, Float.parseFloat("-0.25"));
        negativeModifier2 = ps.getFloat(PROP_NEGATIVE_MODIFIER_2, Float.parseFloat("-0.40"));
        negativeModifier3 = ps.getFloat(PROP_NEGATIVE_MODIFIER_3, Float.parseFloat("-0.66"));
        negation = ps.getFloat(PROP_NEGATION, Float.parseFloat("-1"));
    }


    /**
     * Generates the TextData available to the rest of the
     * text processing chain.
     *
     * @return The next available Data object, returns null if no Data object
     *         is available.
     *
     * @throws DataProcessingException
     *                 If there is a processing error.
     */
    public Data getData() throws DataProcessingException {
        TextData textDataToReturn = null;

        String[] wordSplit = word.split("/");
        wordClass = wordClass.replaceAll("<", "");
        wordClass = wordClass.replaceAll(">", "");
        String[] wordClassSplit = wordClass.split("/");
        String[] wordEmotionalContentSplit = wordEmotionalContent.split("/");
        if (wordClassSplit.length != wordSplit.length) {
            System.out.println("There must have been some kind of problem while parsing the grammar!");
            System.exit(1);
        } else {
            textDataToReturn = new TextData(wordSplit.length);
            WordData temp;
            float modifierValue;
            // wordSplit[0] is a space.
            for (int i = 1; i < wordSplit.length; i++) {
                temp = new WordData(wordSplit[i], wordClassSplit[i]);
                if (wordEmotionalContentSplit[i].equals("true")) {
                    temp.setEmotionalContent();
                }
                modifierValue = ((Float)wordModifierValue.get(i - 1)).floatValue();
                if (modifierValue != 0) {
                    if (modifierValue == negation) {
                        temp.setAsNegationAdverb();
                    } else {
                        temp.setAsModifier();
                        temp.setModifierValue(modifierValue);
                    }
                }
                textDataToReturn.putWordData(temp);
            }
        }
        return textDataToReturn;
    }


    /**
     * Method to initialize the Tokenizer.
     */
    public void initialize() {
        word = "";
        wordClass = "";
        wordEmotionalContent = "";
        wordModifierValue = new ArrayList();
    }


    /**
     * Method to put a word into the system.
     *
     * @param insertionWord The word to be inserted.
     */
    public void putWord(String insertionWord) {
        word = word.concat("/" + insertionWord);
    }


    /**
     * Function to retrieve the words of this Tokenizer.
     *
     * @return The words of this Tokenizer.
     */
    public String getWord() {
        return word;
    }


    /**
     * Method to put a word class into the system.
     * It is assumed that this method is called right after the insertion of
     * a word, so that the lengths of the parsed words and classes of word
     * strings are kept consistent.
     *
     * @param insertionWordClass The word class to be inserted.
     */
    public void putWordClass(String insertionWordClass) {
        wordClass = wordClass.concat("/" + insertionWordClass);
    }


    /**
     * Function to retrieve the word-classes of this Tokenizer.
     *
     * @return The word-classes of this Tokenizer.
     */
    public String getWordClass() {
        return wordClass;
    }


    /**
     * Method to put a possible emotional word into the system.
     * It is assumed that this method is called right after the insertion of
     * a word, so that the lengths of the parsed words and classes of word
     * strings are kept consistent.
     *
     * @param insertionPossibleEmotion The chance to have affective content.
     */
    public void setPossibleEmotionalContent(String insertionPossibleEmotion) {
        wordEmotionalContent = wordEmotionalContent.concat("/" + insertionPossibleEmotion);
    }


    /**
     * Function to retrieve the possible word emotional content of this Tokenizer.
     *
     * @return The possible word emotional content.
     */
    public String getPossibleEmotionalContent() {
        return wordEmotionalContent;
    }


    /**
     * Method to put a modifier value into the queue.
     *
     * @param modifierValue The modifier value.
     */
    public void putModifierValue(float modifierValue) {
        wordModifierValue.add(new Float(modifierValue));
    }


    /**
     * Function to retrieve the list of word modifier values.
     *
     * @return The list of word modifier values.
     */
    public ArrayList getWordModifierValue() {
        return wordModifierValue;
    }


    /**
     * Method to fill this Tokenizer with the appropriate configuration values.
     * This method exists because the objects declared in it need these values
     * and they can't be inherited.
     *
     * @param positiveModifier1 The positive modifier value, level 1.
     * @param positiveModifier2 The positive modifier value, level 2.
     * @param positiveModifier3 The positive modifier value, level 3.
     * @param negativeModifier1 The negative modifier value, level 1.
     * @param negativeModifier2 The negative modifier value, level 2.
     * @param negativeModifier3 The negative modifier value, level 3.
     */
    public void fillConfigurationValues(float positiveModifier1, float positiveModifier2, float positiveModifier3,
    float negativeModifier1, float negativeModifier2, float negativeModifier3, float negation) {
        this.positiveModifier1 = positiveModifier1;
        this.positiveModifier2 = positiveModifier2;
        this.positiveModifier3 = positiveModifier3;
        this.negativeModifier1 = negativeModifier1;
        this.negativeModifier2 = negativeModifier2;
        this.negativeModifier3 = negativeModifier3;
        this.negation = negation;
    }


    /**
     * Method to parse the incoming text with the well defined grammar.
     *
     * @throws Exception If a ParseException occurs.
     */
    public abstract void parseGrammar() throws Exception;


    /**
     * Function to obtain a new initialized instance of the Tokenizer.
     * The real (not abstract) tokenizers should override this function.
     *
     * @param initialization The string to initialize the new Tokenizer.
     *
     * @return The new Tokenizer.
     */
    public abstract Tokenizer getNew(String initialization);


    /**
     * Mehtod to input text data into the system.
     * It is prepared for the optional use of a parser implementation (through the
     * instantiation of a new class).
     * This method labels the Tokenizer module as an INPUTTER.
     *
     * @param theDataToBeInputted The text to be inputted.
     */
    public void inputData(String theDataToBeInputted) throws Exception {
        // Slashes fuck the rest of the pipeline.
        // The outputter must undo this trick.
        theDataToBeInputted = theDataToBeInputted.replace("/", "|");
        Tokenizer tempTokenizer = getNew(theDataToBeInputted);
        tempTokenizer.initialize();
        tempTokenizer.fillConfigurationValues(positiveModifier1, positiveModifier2, positiveModifier3,
            negativeModifier1, negativeModifier2, negativeModifier3, negation);
        tempTokenizer.parseGrammar();
        word = tempTokenizer.getWord();
        wordClass = tempTokenizer.getWordClass();
        wordEmotionalContent = tempTokenizer.getPossibleEmotionalContent();
        wordModifierValue = tempTokenizer.getWordModifierValue();
    }

}

